# Завдання 2.5: Теоретичний аналіз архітектури без лічильника команд

### Питання
Чи можна в схемі виклику процедур обійтися без лічильника команд (IP), використовуючи замість нього вершину стека?

### Обґрунтування
У класичних процесорах (x86_64) лічильник команд (IP) вказує на наступну інструкцію в сегменті `.text`. У суто стековій машині:
1. **Стек замінює IP**: Наступна команда для виконання просто "виштовхується" (pop) з вершини стека.
2. **Код як дані**: Програмний код має бути заздалегідь завантажений у стек у порядку виконання.
3. **Єдиний простір**: Стек стає універсальним сховищем і для команд, і для даних, і для адрес повернення.

---

### Приклади реалізації

1. **Мова Forth**: 
   Це один із найвідоміших прикладів стеково-орієнтованого програмування. Логіка виконання тут базується на маніпуляціях зі стеком, де кожне "слово" (команда) бере параметри та визначає подальші дії через стан стека.

2. **Атаки типу ROP (Return-Oriented Programming)**:
   Приклад із сучасної кібербезпеки системного ПЗ. Зловмисник керує виконанням програми, заповнюючи стек адресами "гаджетів" (коротких послідовностей інструкцій), що закінчуються командою `ret`. Тут саме стек, а не лінійний IP, диктує послідовність виконання коду.

---

### Висновки
Хоча така схема можлива, вона рідко використовується в сучасних процесорах загального призначення (як твій x86_64 в Ubuntu) з наступних причин:
- **Складність циклів**: Для реалізації `for` чи `while` довелося б постійно копіювати інструкції назад у стек, що неефективно.
- **Швидкість**: Постійна робота з пам'яттю (стеком) набагато повільніша за роботу з швидкими регістрами та лінійним лічильником команд.
- **Передбачення переходів**: Сучасні процесори оптимізовані під роботу з IP для швидкого виконання коду.
